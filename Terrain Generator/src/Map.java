import java.util.Random;

/**
 * Map class
 * @author Carson Holt
 * Creates a map generated by perlin noise
 */
public class Map {
	private int size; // the size of the map
	private int xScale; // detail x-axis
	private int yScale; // detail y-axis
	private float heightLimit; // the height limit for the terrain
	private float[][][] Gradient; // the gradient used to form the terrain
	
	/**
	 * Create a new heightmap
	 * @param size - the size of the map
	 * @param height - the height range of the map
	 * @param xScale - the amount of detail on the x-axis
	 * @param yScale - the amount of detail on the y-axis
	 */
	public Map(int size, float height, int xScale, int yScale) {
		this.size = size;
		this.xScale = xScale;
		this.yScale = yScale;
		this.heightLimit = height;
		Gradient = new float[size*xScale][size*yScale][2];
	}
	
	/* Function to linearly interpolate between a0 and a1
	 * Weight w should be in the range [0.0, 1.0]
	 *
	 * as an alternative, this slightly faster equivalent function (macro) can be used:
	 * #define lerp(a0, a1, w) (a0 + w*(a1 - a0)) 
	 */
	float lerp(float a0, float a1, float w) {
	    return (1.0f - w)*a0 + w*a1;
	}
	
	/**
	 * Computes the dot product of the distance and gradient vectors.
	 * @param ix
	 * @param iy
	 * @param x
	 * @param y
	 * @return
	 */
	float dotGridGradient(int ix, int iy, float x, float y) {

	    // Precomputed (or otherwise) gradient vectors at each grid node
	    //float[][][] Gradient = new float[xScale][yScale][2];

	    // Populate the array with random values
	    Random random  = new Random();
	    Gradient[iy][ix][0] = random.nextFloat() * heightLimit;
	    Gradient[iy][ix][1] = random.nextFloat() * heightLimit;
	    
	    // Compute the distance vector
	    float dx = x - (float)ix;
	    float dy = y - (float)iy;

	    // Compute the dot-product
	    return (dx*Gradient[iy][ix][0] + dy*Gradient[iy][ix][1]);
	}

	/**
	 *  Compute Perlin noise at coordinates x, y
	 * @param x
	 * @param y
	 * @return an interpolated value
	 */
	float perlin(float x, float y) {

	    // Determine grid cell coordinates
	    int x0 = (int)x;
	    int x1 = x0 + 1;
	    int y0 = (int)y;
	    int y1 = y0 + 1;

	    // Determine interpolation weights
	    // Could also use higher order polynomial/s-curve here
	    float sx = x - (float)x0;
	    float sy = y - (float)y0;

	    // Interpolate between grid point gradients
	    float n0, n1, ix0, ix1, value;

	    n0 = dotGridGradient(x0, y0, x, y);
	    n1 = dotGridGradient(x1, y0, x, y);
	    ix0 = lerp(n0, n1, sx);

	    n0 = dotGridGradient(x0, y1, x, y);
	    n1 = dotGridGradient(x1, y1, x, y);
	    ix1 = lerp(n0, n1, sx);

	    value = lerp(ix0, ix1, sy);
	    return value;
	}
}
